1. Palindrome - an integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.

2. Ask if input consists of just letter, or any ASCII character. For instance, in https://leetcode.com/problems/longest-substring-without-repeating-characters/, I thought it will only contain english letter, and I use arr[26] as a hash. This is not right. The input can contain both upper case and lower case. More importantly, it can contain any ascii charecter.

3. Note that, there are 256 ascii characters.

4. In  sliding window implementation, you can start end = [0 - end] and increase start on the way

5. Suppose you are given https://leetcode.com/problems/median-of-two-sorted-arrays/. You need to asked to solve in log (n + m). How would you do that? Actually, if you use two pointers for two arrays, it's actually log (n + m). This is because you don't need to iterate the whole array. Actually, no that's not right. If you use simple, two pointers, it's O(n+m). However, I saw my solution  was accepted and it was faster that 99...% solutions

6. https://leetcode.com/problems/reverse-integer/. Here, I thought, I will have to rotate the number in each step up to n times (n = num of digits). If you think clearly, if you ratate a number n times, you will get the same number. If you rotate n - 1 times, it will still give you wrong results. To get the right results, you need to swap between start and end.

7. We know that C++ string is immutatable. If we append or use '+' operator, it creates a new copy of the object. So, you may want to create a sring of a predefined length. You can do that as:

        string res(str_len, 0);//Here, we are assigning 0/NULL to each element of the string
        
8. https://leetcode.com/problems/base-7/. How many characters do you need for base 7? How do you convert a number from base 10 to base 7?

Recall that, for base-10 numbers, we can calculate the number of digits as = log10(num) + 1. It will work for any number, for instance, 99, 100,...

In the same way, base-2 number, the number of binary digits is = log2(num) + 1.

In the same way, for base-7 number, the number of digits = log7(num) + 1.

How to calculate log7(num)? There is no such library function.

log7(num) = log10(num) / log10(7).

Note that, this will not work if the number is negative. So, if the number is negative, you need to make it positive and then process it.


How do calculate base-7 number from base-10? 

Recall that, in Base-16, we divide by 16 in each step, and get the quotient (result of the division) and remainder. We divide the quotient again by 16. We repeat these utill quotient is 0. Like:

16 |45
   |---------------------
16 |2 - 13 (D)
   -----------------------
   |0  - 2 (2)
   
So, Hex of 45 is 2D   

In the same way, for base-7, we need to divide by 7.

Will this work if input is 0? No. You need to handle 0 separately. If the number is negative, you also need to make the number positive first.

9. https://leetcode.com/problems/reverse-linked-list/ Here, I need to set head = nullptr.

10. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Here, we can use mid = (start + end) >> 1

11. https://leetcode.com/problems/reverse-bits/. Note that reversing is not same as circulating. I often make this mistake. Remember string reverse procedure

12. https://leetcode.com/problems/reverse-bits/ Here, if (n & mask2 == 0) will not work. It should be if ((n & mask2) == 0)

13. https://leetcode.com/problems/linked-list-cycle-ii/. Detecting cycle is easy. How would you find the start of the cycle?

Don't go into theory. That's just for correctness proof. Idea is only you find the intersection of fast and slow pointer, do the following. Have ptr1 point the head and have ptr2 point the intersection. Then go only one step at a time for both case. When they meet, that's the start of the cycle.

14. https://leetcode.com/problems/invert-binary-tree/

Here, I set left-subtree = invert(right-subtree). Problem here is it will update the tree in place. Don't do that. Create a temp, left, right. Then update the tree based on left and right as:

        TreeNode *left = invertTree (root->right);
        TreeNode *right = invertTree (root->left);
        root->left = left;
        root->right = right;

15. https://leetcode.com/problems/sqrtx/

A binary search needs to be in the form:

while (end >= start) {//Not end > start
  mid = (start + end) >> 1;
  if (target == arr[mid])
    return mid;
  else if (target > arr[mid])
    start = mid + 1;//NOT start = mid (leads to infinite loop)
  else
    end = mid - 1;  //NOT end = mid (leads to infinite loop)
}

Also, in the problem, don't do:

 if ((x + 1) * (x + 1) > target) 
 
 What's wrong here? It may overflow for some input. Even if(x + x > target) or if (x * x > target) may overflow.
 
 If you need to calculate sum or multiplication of int/float, check if you need "long long" (for int) or "double" (for float) to store it. Otherwise overflow happens. If you need long long or double, also change the expression to make sure that longlong or double is stored. For instance,

int a, b;
long long sum;

sum = (long long)a + b;

Just changing to long long inline doesn't work.

In some cases, you may not need "long long". Just "long" is enough.

16. https://leetcode.com/problems/kth-largest-element-in-a-stream/

What's wrong with the code?

	vector<int> nums;
        for (int i = 0; i < nums.size() - k; i++) {

        }
        
Here, nums.size() is unsigned. If nums.size() - k is negative, that expression will accidentally create a large number. So, the loop will mistakenly run many iteration whearas it shouldn't iterate at all.
        
Following doesn't fix it.


        for (int i = 0; i < (int)nums.size() - k; i++) {

        }
        
This however fixes it:
        
        int num_delete = nums.size() - k;
        for (int i = 0; i < num_delete; i++) {

        }
        
17. https://leetcode.com/problems/power-of-three/ 

Look at the following solution:

    bool isPowerOfThree(int n) {
        if (n <= 0)
            return false;
        
       float x = (float)log10(n) / log10(3);
       return ceil(x) == x;//See how we are checking if x is an integer.
    }
    
    What's wrong with the code? Here, it should be:
    
    double x = log10(n) / log10(3);
    
    Casting it to float may lose precision, which causes wrong result. Also, x should be double.
    
18. https://www.geeksforgeeks.org/position-of-rightmost-set-bit/

The process is:
     
    unsigned int getFirstSetBitPos(int n)
    {
        return log2(n & -n) + 1;
    }
    
    If you take negative of the number (two's complement) and & it with the original #, all the bits except the right most one is set. Then, use log to calculate the bit position.
    
    For instance, n = 100011100
    
    One's complement of n = 011100011
    Two's complement of n = 011100100. This is -n
    
    Now, n & -n = 100.
    
19. https://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap/325964#325964
    https://leetcode.com/problems/rectangle-overlap/
    
Here, we need to write the condition such that they don't overlap, instead of checking overlapping. For rectangale, first remember how you do it for line. That will help you to come up with logics for rectangles.
    
20. https://leetcode.com/problems/number-of-days-between-two-dates/. How to solve this? Trying to implement distance between them is hard/messy to implement. But, if you try to calculate # of days since 1970, that's clean to implemt. So, implement that, and then take the distance as:

class Solution {
    bool is_leapyear(int year) {
        if (year % 100 == 0)
            return year % 400 == 0;
        return (year % 4 == 0);
    }
    
    int since_epoc (string date) {
        int months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        int year = stoi(date.substr(0, 4));
        int mon = stoi(date.substr(5, 2));
        int day = stoi(date.substr(8));
        
        int i = 1970;
        while (year > i) {
            day += is_leapyear(i) ? 366 : 365;
            i++;
        }
        for (int i = 1; i <= mon - 1; i++) {
            day += months[i];
            if (i == 2 && is_leapyear(year))
                day++;
        }
        return day;
    }
public:
    int daysBetweenDates(string date1, string date2) {
        //cout << since_epoc (date2);
        return abs(since_epoc (date2) -  since_epoc (date1));
    }
};

Note how we represented # of days in a month. That's more clean than having switch/if to clauclate it.

21. https://leetcode.com/problems/valid-square/

Very interesting problem. Try to find how you would solve it. 

Trick is to sort the numbers. That way, you know what is the bottom left and top right.

22. https://leetcode.com/problems/snakes-and-ladders/

How would you convert <x, y> to the number? Think in terms of math. Here, we are doing that:

        for (int i = board.size() - 1; i >= 0; i--) {
            for (int j = 0; j < board.size(); j++) {
                if (right)
                    jump[(board.size() - 1 - i) * board.size() + j + 1] = board[i][j];
                else
                    jump[(board.size() - 1 - i) * board.size() + (board.size() - 1- j) + 1] = board[i][j];
            }
            right = !right;
        }   
    
23. https://leetcode.com/problems/product-of-array-except-self/

How can you implement this without using division?

You can have two arrays L and R. L will contain multiplication of all the number to the left of index i. R will contain multiplication of all the number to the right of index i.
Then for each index, you can do L[i] * R[i]     


24. https://leetcode.com/problems/3sum/

Here, challenge is how to make sure you don't put same result twice?

You may try to use hash. But, it will not work. Beacuse, the numbers inside result will not be in the same order. Besides, you iterate samrtly so that you can avoid duplicate.

First of all, sort the array. In outer array, check if the number you are dealing is same as the previous number. If yes, you can skip that.

In the inner array where you are doing two sum, if you find a match for a number, increase the index until the next number is same as the previous number. 

The code will look as following:

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        int target_sum;
        
        sort (nums.begin(), nums.end());////<<<<<<<<<<<<<<<<<<<<<
        for (int i = 0; i < nums.size() - 2; i++) {
            if (i > 0 && nums[i] == nums[i-1]) {////<<<<<<<<<<<<<<<<<<<<<
                continue;
            }
            target_sum = 0 - nums[i];
            unordered_set<int> set;
            for (int j = i + 1; j < nums.size();) {
                if (set.count(target_sum - nums[j])) {
                    vector<int> inner (3);
                    inner[0] = nums[i];
                    inner[1] = nums[j];
                    inner[2] = target_sum - nums[j];
                    res.push_back(inner);
                    j++;
                    while (j < nums.size() && nums[j] == nums[j-1])////<<<<<<<<<<<<<<<<<<<<<
                        j++;
                    continue;
                }
                set.insert(nums[j]);
                j++;
            }
        }
        return res;
    }
};

25. https://leetcode.com/problems/3sum-closest/

How do you calculate the distance between target and sum? Note that, both can be positive and negative.

When doing this, I made it overly complicated, and created a separte function for this. But, it should be abs(target - sum). Think about it. It will work for both positive and negative.

Now how would you implement this?

What I thought was, I would use two pointer approach. I will keep track of the last diff. In two pointer iteration, I would minimize the diff. If we see that diff is increasing compared to previous diff, we should break. This is not right. If diff increases, you should not break because you can still find a smaller diff. Then what's the point of using two pointers? The main benefit is, if we find a diff 0, we can immediately stop.

I also was thinking about 3 nested loop, because I though the inner loop will stop pretty soon. This is not the right approach either. First of all, this is O(n^3). Two pointer approach make the same problem O(n^2)

26. https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/

Do you implemement using DFS or BFS? I think, both solution works. But, text books are other solutions uses DFS instead of BFS. I didn't find a good explanation why. At first, I though DFS would be better because we don't really iterate all the edges. As DFS goes to depth first, it will find the solution sooner. But, this is not the case. Both DFS and BFS is O(E + V). DFS will eventually check all the edges of the nodes along the way (if the node isn't already visited). So, I think, there is a chance that DFS would be better, but it's not certain.

Also, how would you create adjacency list here?

I am inclind to think that, here I can create it as:

        for (auto &e : edges) {
            adj_list[e[0]].push_back(e[1]);
        } 
As I am primarily interested to mark all the nodes, so I don't really consider opposite direction of the edge. This however will not work in all the cases. We don't know which we will be visiting the nodes. So, correct answer should be: 
        
        for (auto &e : edges) {
            adj_list[e[0]].push_back(e[1]);
            adj_list[e[1]].push_back(e[0]);
        }
        
        
27. https://leetcode.com/problems/delete-node-in-a-linked-list/

Do you remember the trick? If you remember, then you are find. Otherwise just take a look at the solution. Implementation should be easy.     

28. Try to remember if you can implement in-order, pre-order, post-order travarsal without recursion.   
