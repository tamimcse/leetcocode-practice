1. Palindrome - an integer is a palindrome when it reads the same backward as forward. For example, 121 is a palindrome while 123 is not.

2. Ask if input consists of just letter, or any ASCII character. For instance, in https://leetcode.com/problems/longest-substring-without-repeating-characters/, I thought it will only contain english letter, and I use arr[26] as a hash. This is not right. The input can contain both upper case and lower case. More importantly, it can contain any ascii charecter.

3. Note that, there are 256 ascii characters.

4. In  sliding window implementation, you can start end = [0 - end] and increase start on the way

5. Suppose you are given https://leetcode.com/problems/median-of-two-sorted-arrays/. You need to asked to solve in log (n + m). How would you do that? Actually, if you use two pointers for two arrays, it's actually log (n + m). This is because you don't need to iterate the whole array. Actually, no that's not right. If you use simple, two pointers, it's O(n+m). However, I saw my solution  was accepted and it was faster that 99...% solutions

6. https://leetcode.com/problems/reverse-integer/. Here, I thought, I will have to rotate the number in each step up to n times (n = num of digits). If you think clearly, if you ratate a number n times, you will get the same number. If you rotate n - 1 times, it will still give you wrong results. To get the right results, you need to swap between start and end.

7. We know that C++ string is immutatable. If we append or use '+' operator, it creates a new copy of the object. So, you may want to create a sring of a predefined length. You can do that as:

        string res(str_len, 0);//Here, we are assigning 0/NULL to each element of the string
        
8. https://leetcode.com/problems/base-7/. How many characters do you need for base 7? How do you convert a number from base 10 to base 7?

Recall that, for base-10 numbers, we can calculate the number of digits as = log10(num) + 1. It will work for any number, for instance, 99, 100,...

In the same way, base-2 number, the number of binary digits is = log2(num) + 1.

In the same way, for base-7 number, the number of digits = log7(num) + 1.

How to calculate log7(num)? There is no such library function.

log7(num) = log10(num) / log10(7).

Note that, this will not work if the number is negative. So, if the number is negative, you need to make it positive and then process it.


How do calculate base-7 number from base-10? 

Recall that, in Base-16, we divide by 16 in each step, and get the quotient (result of the division) and remainder. We divide the quotient again by 16. We repeat these utill quotient is 0. Like:

16 |45
   |---------------------
16 |2 - 13 (D)
   -----------------------
   |0  - 2 (2)
   
So, Hex of 45 is 2D   

In the same way, for base-7, we need to divide by 7.

Will this work if input is 0? No. You need to handle 0 separately. If the number is negative, you also need to make the number positive first.

9. https://leetcode.com/problems/reverse-linked-list/ Here, I need to set head = nullptr.

10. https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ Here, we can use mid = (start + end) >> 1

11. https://leetcode.com/problems/reverse-bits/. Note that reversing is not same as circulating. I often make this mistake. Remember string reverse procedure

12. https://leetcode.com/problems/reverse-bits/ Here, if (n & mask2 == 0) will not work. It should be if ((n & mask2) == 0)

13. https://leetcode.com/problems/linked-list-cycle-ii/. Detecting cycle is easy. How would you find the start of the cycle?

Don't go into theory. That's just for correctness proof. Idea is only you find the intersection of fast and slow pointer, do the following. Have ptr1 point the head and have ptr2 point the intersection. Then go only one step at a time for both case. When they meet, that's the start of the cycle.

14. https://leetcode.com/problems/invert-binary-tree/

Here, I set left-subtree = invert(right-subtree). Problem here is it will update the tree in place. Don't do that. Create a temp, left, right. Then update the tree based on left and right as:

        TreeNode *left = invertTree (root->right);
        TreeNode *right = invertTree (root->left);
        root->left = left;
        root->right = right;

15. https://leetcode.com/problems/sqrtx/

A binary search needs to be in the form:

while (end >= start) {//Not end > start
  mid = (start + end) >> 1;
  if (target == arr[mid])
    return mid;
  else if (target > arr[mid])
    start = mid + 1;//NOT start = mid (leads to infinite loop)
  else
    end = mid - 1;  //NOT end = mid (leads to infinite loop)
}

Also, in the problem, don't do:

 if ((x + 1) * (x + 1) > target) 
 
 What's wrong here? It may overflow for some input. Even if(x + x > target) or if (x * x > target) may overflow.
 
 If you need to calculate sum or multiplication of int/float, check if you need "long long" (for int) or "double" (for float) to store it. Otherwise overflow happens. If you need long long or double, also change the expression to make sure that longlong or double is stored. For instance,

int a, b;
long long sum;

sum = (long long)a + b;

Just changing to long long inline doesn't work.

In some cases, you may not need "long long". Just "long" is enough.

16. https://leetcode.com/problems/kth-largest-element-in-a-stream/

What's wrong with the code?

	vector<int> nums;
        for (int i = 0; i < nums.size() - k; i++) {

        }
        
Here, nums.size() is unsigned. If nums.size() - k is negative, that expression will accidentally create a large number. So, the loop will mistakenly run many iteration whearas it shouldn't iterate at all.
        
Following doesn't fix it.


        for (int i = 0; i < (int)nums.size() - k; i++) {

        }
        
This however fixes it:
        
        int num_delete = nums.size() - k;
        for (int i = 0; i < num_delete; i++) {

        }
        
17. https://leetcode.com/problems/power-of-three/ 

Look at the following solution:

    bool isPowerOfThree(int n) {
        if (n <= 0)
            return false;
        
       float x = (float)log10(n) / log10(3);
       return ceil(x) == x;//See how we are checking if x is an integer.
    }
    
    What's wrong with the code? Here, it should be:
    
    double x = log10(n) / log10(3);
    
    Casting it to float may lose precision, which causes wrong result. Also, x should be double.
    
18. https://www.geeksforgeeks.org/position-of-rightmost-set-bit/

The process is:
     
    unsigned int getFirstSetBitPos(int n)
    {
        return log2(n & -n) + 1;
    }
    
    If you take negative of the number (two's complement) and & it with the original #, all the bits except the right most one is set. Then, use log to calculate the bit position.
    
    For instance, n = 100011100
    
    One's complement of n = 011100011
    Two's complement of n = 011100100. This is -n
    
    Now, n & -n = 100.
    
19. https://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap/325964#325964
    https://leetcode.com/problems/rectangle-overlap/
    
Here, we need to write the condition such that they don't overlap, instead of checking overlapping. For rectangale, first remember how you do it for line. That will help you to come up with logics for rectangles.
    
20. https://leetcode.com/problems/number-of-days-between-two-dates/. How to solve this? Trying to implement distance between them is hard/messy to implement. But, if you try to calculate # of days since 1970, that's clean to implemt. So, implement that, and then take the distance as:

class Solution {
    bool is_leapyear(int year) {
        if (year % 100 == 0)
            return year % 400 == 0;
        return (year % 4 == 0);
    }
    
    int since_epoc (string date) {
        int months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        int year = stoi(date.substr(0, 4));
        int mon = stoi(date.substr(5, 2));
        int day = stoi(date.substr(8));
        
        int i = 1970;
        while (year > i) {
            day += is_leapyear(i) ? 366 : 365;
            i++;
        }
        for (int i = 1; i <= mon - 1; i++) {
            day += months[i];
            if (i == 2 && is_leapyear(year))
                day++;
        }
        return day;
    }
public:
    int daysBetweenDates(string date1, string date2) {
        //cout << since_epoc (date2);
        return abs(since_epoc (date2) -  since_epoc (date1));
    }
};

Note how we represented # of days in a month. That's more clean than having switch/if to clauclate it.

21. https://leetcode.com/problems/valid-square/

Very interesting problem. Try to find how you would solve it. 

Trick is to sort the numbers. That way, you know what is the bottom left and top right.

22. https://leetcode.com/problems/snakes-and-ladders/

How would you convert <x, y> to the number? Think in terms of math. Here, we are doing that:

        for (int i = board.size() - 1; i >= 0; i--) {
            for (int j = 0; j < board.size(); j++) {
                if (right)
                    jump[(board.size() - 1 - i) * board.size() + j + 1] = board[i][j];
                else
                    jump[(board.size() - 1 - i) * board.size() + (board.size() - 1- j) + 1] = board[i][j];
            }
            right = !right;
        }   
    
23. https://leetcode.com/problems/product-of-array-except-self/

How can you implement this without using division?

You can have two arrays L and R. L will contain multiplication of all the number to the left of index i. R will contain multiplication of all the number to the right of index i.
Then for each index, you can do L[i] * R[i]     


24. https://leetcode.com/problems/3sum/

Here, challenge is how to make sure you don't put same result twice?

You may try to use hash. But, it will not work. Beacuse, the numbers inside result will not be in the same order. Besides, you iterate samrtly so that you can avoid duplicate.

First of all, sort the array. In outer array, check if the number you are dealing is same as the previous number. If yes, you can skip that.

In the inner array where you are doing two sum, if you find a match for a number, increase the index until the next number is same as the previous number. 

The code will look as following:

class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        int target_sum;
        
        sort (nums.begin(), nums.end());////<<<<<<<<<<<<<<<<<<<<<
        for (int i = 0; i < nums.size() - 2; i++) {
            if (i > 0 && nums[i] == nums[i-1]) {////<<<<<<<<<<<<<<<<<<<<<
                continue;
            }
            target_sum = 0 - nums[i];
            unordered_set<int> set;
            for (int j = i + 1; j < nums.size();) {
                if (set.count(target_sum - nums[j])) {
                    vector<int> inner (3);
                    inner[0] = nums[i];
                    inner[1] = nums[j];
                    inner[2] = target_sum - nums[j];
                    res.push_back(inner);
                    j++;
                    while (j < nums.size() && nums[j] == nums[j-1])////<<<<<<<<<<<<<<<<<<<<<
                        j++;
                    continue;
                }
                set.insert(nums[j]);
                j++;
            }
        }
        return res;
    }
};

25. https://leetcode.com/problems/3sum-closest/

How do you calculate the distance between target and sum? Note that, both can be positive and negative.

When doing this, I made it overly complicated, and created a separte function for this. But, it should be abs(target - sum). Think about it. It will work for both positive and negative.

Now how would you implement this?

What I thought was, I would use two pointer approach. I will keep track of the last diff. In two pointer iteration, I would minimize the diff. If we see that diff is increasing compared to previous diff, we should break. This is not right. If diff increases, you should not break because you can still find a smaller diff. Then what's the point of using two pointers? The main benefit is, if we find a diff 0, we can immediately stop.

I also was thinking about 3 nested loop, because I though the inner loop will stop pretty soon. This is not the right approach either. First of all, this is O(n^3). Two pointer approach make the same problem O(n^2)

26. https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/

Do you implemement using DFS or BFS? I think, both solution works. But, text books are other solutions uses DFS instead of BFS. I didn't find a good explanation why. At first, I though DFS would be better because we don't really iterate all the edges. As DFS goes to depth first, it will find the solution sooner. But, this is not the case. Both DFS and BFS is O(E + V). DFS will eventually check all the edges of the nodes along the way (if the node isn't already visited). So, I think, there is a chance that DFS would be better, but it's not certain.

Also, how would you create adjacency list here?

I am inclind to think that, here I can create it as:

        for (auto &e : edges) {
            adj_list[e[0]].push_back(e[1]);
        } 
As I am primarily interested to mark all the nodes, so I don't really consider opposite direction of the edge. This however will not work in all the cases. We don't know which we will be visiting the nodes. So, correct answer should be: 
        
        for (auto &e : edges) {
            adj_list[e[0]].push_back(e[1]);
            adj_list[e[1]].push_back(e[0]);
        }
        
        
27. https://leetcode.com/problems/delete-node-in-a-linked-list/

Do you remember the trick? If you remember, then you are find. Otherwise just take a look at the solution. Implementation should be easy.     

28. Try to remember if you can implement in-order, pre-order, post-order travarsal without recursion.

29. Note that many tree problem such as LCA and find distance between two nodes can be implemented by using recursion on left and right. Think hard how you can formulate that.

30. https://leetcode.com/problems/best-time-to-buy-and-sell-stock/

How would you implement this?

I generally think that, I will find a min to the left and max to the right. Then I will increase the min until I find a lower min. I usually do this because I treat loop as stateless loop. But, we can add state in a loop and do wonderful things. Try to find out if we can have multiple states so that we can find it in one iteration. If you can't, look at the leetcode solution.

31. How to implement heap? priority queue. How to implement max heap? This is simply:

priority_queue<int> q;
p.top()//Note this is not p.front()

For min heap, it should be:

priority_queue<int, vector<int>, greater<int>> pq;//yes, greater<int>, not 'greater' or 'less'. You also need to add vector<int>  

Also, note that priority queue can have size as: pq.size() 

Note that, we generally don't create a heap of size n (I sometimes think of this). We create an empty heap and then add/delete elements to it.

32. https://leetcode.com/problems/validate-binary-search-tree/

How would you implement this? It may look simple on the surface, but note that all the nodes in left subtree has to be smaller. Try to find the solution. Look at my solution if you can't find.

Here is the soluton.

class Solution {
    bool isValidBST_inner(TreeNode* root, long min, long max) {//<<<<<<<<<<<<
        if (!root)
            return true;
        if (root->left && root->left->val >= root->val)
            return false;
        if (root->right && root->right->val <= root->val)
            return false;
        
        if (root->val >= max || root->val <= min)
            return false;
        
        return isValidBST_inner(root->left, min, root->val) && 
               isValidBST_inner(root->right, root->val, max);        
    }
public:
    bool isValidBST(TreeNode* root) {
        return isValidBST_inner(root, (long)INT_MIN * 2, (long)INT_MAX * 2);//<<<<<<<<<<<<
    }
};

Note that the pointers. You can actually avoid it by passing node pointer instead of the value (as leetcode solution suggests)

Note that, this problem can be solved using in-order travarsal. If you do in-order travarsal, the nodes will be visited in sorted order. Implementing in-order in recursive manner is easy, but implementing it in iterative manner isn't easy. Here. we are implementing it using recursive in-order.

class Solution {
    
    bool isValidBST_inner(TreeNode* root, TreeNode* &prev) {
        bool ret;
        
        if (!root)h?
            return true;
        ret = isValidBST_inner(root->left, prev);
        if (!ret)
            return false;
        if (prev && root->val <= prev->val)
            return false;
        prev = root;
        ret = isValidBST_inner(root->right, prev);
        if (!ret)
            return false;
        return true;
    }

public:
    bool isValidBST(TreeNode* root) {
        TreeNode* prev = nullptr;
        return isValidBST_inner(root, prev);///<<<<<<
    }
};

Note that, if you try to pass a default value at the pointer, the program will be error prone. Passing pointer is less error prone.


33. https://leetcode.com/problems/search-in-rotated-sorted-array/

How would you implement this? What I try to do is do binary search. During binary search, I try to increase/decrase the mid based on which part I'm in. I found it extreamly difficult to solve although leetcode solution 2 use the same approach. Easier approach is to use binary search to find the smallest element. Then do two separate binary search on two parts.

How would you find the smallest element using binary search? To solve this problem (like stock buy sell problem), draw the points as following:


         A
       A
     A
   A
A  
                 A
               A
             A
------------------------------
Now you can see what logic to use to find the smalles index. If you don't, look at the solution or leet code approach 1.

34. https://leetcode.com/problems/set-matrix-zeroes/

How would you implement? Note that, evenn though you asked to use O(1) space, you can use additional variable

35. https://leetcode.com/problems/kth-largest-element-in-an-array/

Note that, this is asked to solve in O(n). If you use heap, this is not exactly O(n). It's O(nlong). But, that's OK.

36. https://leetcode.com/problems/insert-interval/

Draw interval on paper and thing how would you implement binary search here. It seems that you can use binary search here, but you cannot. Look at the eaxmple:

------      ---------  ------------           -----------    ----------

        ---------- (to insert). You can use binary search to find the insertion point for this.
 -------------------------------------------------- (Now how about this? What would be the conditio that you use to do binary search both situation). I couldn't formulate an easy condition. Leetcode solution also use sequencial serach.
 
 37.    vector<vector<char>> mat(numRows);
        for (int i = 0; i < numRows; i++) {
            mat[i].resize(num_col);
        }
        
Note that, all the elements of the vector will be 0 by deafault.

38. https://leetcode.com/problems/zigzag-conversion/

Here, I use 2D array to implement this. Can you make it better?

Note that, you can simply have a vector<string> instead of 2D array.        
 
 
37. https://leetcode.com/problems/min-cost-to-connect-all-points/

How would you implememt this?

How would you implement MST?

https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/
https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/

Suppose, you want to implemenmt Kruskal's algorithm. How would you implement it?

How would you check cycle in it? DFS? I sometimes think that I can keep track of visit[] for each point. Can I use that to detect cycle?

You can't. Think of the following:

A     C
|     |
|     |
B     D

All the points are visited, but you can still add edge between A and C. 

So, detecting cycle in graph using DFS is expensive. You can use the above intuition to implement disjoint set data structure.

How would you implement disjoint set?

One option is to have a vector<unordered_set<int>>. This is expesive. How would you merge disjoint sets? We need a data structure that supports that.

class DisjointSet {
    vector<int> parent;
public:    
    DisjointSet (int n) {
        parent = vector<int>(n);//<<<<<<< See how we are creating a vector dynamically for member variable
        
        for (int i = 0; i < n; i++)
            parent[i] = i;
    }
    
    int find (int n) {//<<<< find
        while (n != parent[n]) {
            n = parent[n];
        }
        return n;
    }
    
    bool merge (int a, int b) {//<<<< Merge
        int p1 = find (a);
        int p2 = find (b);
        
        if (p1 == p2)
            return false;
        parent[p1] = p2;
        return true;
    }
};

The total solution is:

class Solution {
public:
    int minCostConnectPoints(vector<vector<int>>& points) {
        vector<vector<int>> edge_list;
        
        for (int i = 0; i < points.size(); i++) {
            for (int j = i + 1; j < points.size(); j++) {
                vector<int> edge(3);
                edge[0] = i;
                edge[1] = j;
                edge[2] = abs (points[i][0] - points[j][0]) + 
                    abs (points[i][1] - points[j][1]);
                edge_list.push_back(edge);
            }
        }
        
        sort (edge_list.begin(), edge_list.end(), [](vector<int> &v1, vector<int> &v2) {
            return v1[2] <= v2[2];
        });
        
        DisjointSet ds(points.size());
        int cost = 0;
        int count = 0;
        for (auto &e : edge_list) {
            if (ds.merge(e[0], e[1])) {
                count++;
                cost += e[2]; 
                if (count == points.size() - 1)//<<<< See we can stop early when we have n-1 edges
                    return cost;
            }
        }
        return 0;
    }
};
       
38. https://leetcode.com/problems/partition-list/

How would you implement this? Note that, sometimes it's OK to create a dummy pointer (ListNode dummyNode), just to avoid complicated check;

39. https://leetcode.com/problems/all-paths-from-source-to-target/

How would you implement it? Note that, you need to implement backtracking in DFS. It is easier to implement backtacking DFS in recursive manner instead of iteratve manner.

40. https://leetcode.com/problems/powx-n/

How would you implememnt this?

I generally do: pow (x, n/2) * pow (x, n - n/2). But, note that, you are calling almost similar function twice. This will result in TLE. You can rather do:

            res = myPow(x, n/2);
            res = res * res;
            if (n & 1)
                res *= x;
                
Also, note that, if n is negative, you need to do n = -n. This will however cause overflow for the largest negative integer. To solve this problem, do following:

        long N = n;
        bool neg = n < 0;

        if (neg)
            N = -N;                

41. https://leetcode.com/problems/reverse-integer/

How to solve this? I generally solve as:

https://leetcode.com/problems/reverse-integer/

class Solution {
public:
    int reverse(int x) {
        unsigned int X = x < 0 ? -x : x;//<<<<<<Can it cause overflow? Ypu would think No, because it's unsigned. But it will overflow. Use abs() to achive this

        unsigned int num = 0;
        while (X) {
            num = num * 10 + X % 10;//<<<<<<Can it cause overflow? Yes. I usually solve this uinng "long" or "long long", but we cannot use 64 bit int here. 
            X = X/10;
        }

        return x < 0 ? -num : num;
    }
};

Note that, not being able to use 64 bit int is the main challenge here. We need to implement in a way that it can detect overflow. Now, we need to detect overflow before it actually happens. Because if overflow happens, you cannot detect it. So, we can use following approach:

class Solution {
public:
    int reverse(int x) {
        bool neg = x < 0;
        unsigned int X = abs(x);///<<< Don't do -x. It will cause overflow

        unsigned int num = 0;
        while (X) {
            if (!neg && (num > INT_MAX/10 || (num == INT_MAX/10 && X % 10 > 7))) {///<<<<<See how we are avoiding overflow for positive #
                return 0;
            }
            if (neg && (num > INT_MAX/10 || (num == INT_MAX/10 && X % 10 > 8))) {///<<<<<See how we are avoiding overflow for negative #
                return 0;
            }
            num = num * 10 + X % 10;
            X = X/10;
        }

        return neg ? -num : num;
    }
};  

42. https://leetcode.com/problems/lru-cache/

How would you implememnt this? 

I tend to use hash and heap. I also though about using hash and queue. But, if you think carefully, they will not work. But, note that, you can implment using hash + linked list where hash points to the linked list nodes. Everytime you access a node, that node will be pushed to the head. When we delete a node, we will be delete from tail. Which linked list should you use? should you use std::list?

I found that moving around items can be difficult in std::list. So, avoid it. Implement your own list unless what you are doing something trivial like push_back(), pop_back(), push_front(), pop_front(). Note that, std::list has those functions. Although list has splice() that allows you to insert one list into another, it's hard to use if you want to reorder nodes in a list using it.

Now, would you use single linked list or double linked list? Note that, here double linked list will result in O(1) reoorder (although Single linked list also can have tail)

When implementing linked list of your own, don't forget to do these:

class Node {
public:
    int key;
    int val;
    Node *next;
    Node *prev;
    Node(int k, int v) {
        key = k;
        val = v;
        next = nullptr;//<<<<<<<<I usually forget this
        prev = nullptr;//<<<<<<<<I usually forget this
    }
};

Also, remember that hash has size() function that can give us the size. Hash also has following way to delete a key:

hash.erase(key_to_del);//<<<<You don't need to pass an iterator

43. https://leetcode.com/problems/lfu-cache/

How would you implememt this? 

I think of implememting as hash + priority_queue. Here, priority_queue will contain the nodes (with frequency) and hash points to the node. This however will not work. Because, in C++ priority_queue, you only get top and you can only do push() which will add the item to the bottom of the tree. But, in this case, we may need to update the frequency of an intermediate node. If you do that, priority_queue acts abnormally. To solve this, we can implement our own heap.

Now, even though we don't use heap, let's take a how the heap code would look like:

struct Elem {//<<<<<<<Note that stuct/class name should begin with capital letter.
    int key;
    int val;
    int freq;
    Elem(int k, int v, int f) {//<<<<<<<<<<<<You can add constructor in struct like a class
        key = k;
        val = v;
        freq = f;
    }
};

unordered_map<int, Elem *> hash;//<<<<<Notde that, you don't need struct keyword for struct
Elem *new_elem = new Elem(key, value, 1);//You can also create a struct onbject like a class

//<<<<<Note how functor is written
struct Comp{
    bool operator()(Elem *e1, Elem *e2){//<<< Note that there are two "()". You also need to return true
        return e1->freq < e2->freq;
    }
};

priority_queue<Elem *, vector<Elem *>, Comp> pq;//<<<<<For custom object, we need to give less/greater than function. Here, we need to provide a functor
               
Now, even though you could implement your own heap, that will require you update multiple elements in every iteration. Can you do better?

Yes, you can have a hash<frequency, nodelist>. Here, you will keep all the nodes that have the same frequency in the same bucket. When you update the frequency, you simply need to move the node from current bucket to new bucket. You may think that, here we need linear search to find the node. But, actually you don't. Note that, each node is allocated dynamically. Here, we simply keep the pointer to the node, not the actual node. So, this frequncy hash and key hash will point to the same node. You can move nodes easily around.

You so you need to two hash, right? One keep track of <key, Node*>, another <freq, node>. But, note that, in case of <freq, node>, you sometimes need to find the smallest frequncy? How can you do that. Use map!!!! Remember that map is an ordered_map (internally a red black tree). So, you can easily find the smallest freq as:

map.begin()..

Now, in the requirment it also says that, if there are multiple LFU element, evict the LRU element. So, you need to keep track of the LRU as well. So, solve this problem, we always insert at the end of the list and evict from the head of the list. To implemement that efficiently, we need both head and tail. So, this is the actual implementation:

/*
https://leetcode.com/problems/lfu-cache/
*/
struct Node {
    int key;
    int val;
    int freq;
    Node *next;
    Node *prev;
    Node(int k, int v, int f) {
        key = k;
        val = v;
        freq = f;
        next = NULL;
        prev = NULL;
    }
};

class LFUCache {
    unordered_map<int, Node *> hash;//<<<<.....
    map<int, pair<Node*, Node*>> freq_list;//<<<<See how we are keeping both head and tail
    int size;
    
    void insert_last(Node* &head, Node* &tail, Node *to_insert) {
        if (!head) {
            head = to_insert;
            tail = to_insert;
        } else {///<<<<<In linked list manipulation, everytime you have a condition, make sure to think if you need to do if the condition doesn't hold (i sometimes miss that)
            tail->next = to_insert;
            to_insert->prev = tail;
            tail = tail->next;
        } 
    }
    
    void delete_cur(Node* &head, Node* &tail, Node *to_del) {//<<<<<Note how we pass pointer by reference. It's not like: "Node &*head"
        if (head == to_del) {
            head = head->next;
            if (head)
                head->prev = NULL;
            else
                tail = NULL;
        } else if (tail == to_del) {
            tail->prev->next = NULL;
            tail = tail->prev;
        } else {
            if (to_del->next) {
                to_del->next->prev = to_del->prev;   
            }
            to_del->prev->next = to_del->next;
        }
        to_del->next = NULL;
        to_del->prev = NULL;
    }
    
    void print_freq() {
        cout << "printing freq list:\n";
        for (auto it = freq_list.begin(); it != freq_list.end(); it++) {
            Node *r = it->second.first;
            while (r) {
                cout << "key = " << r->key << " value = " << r->val << " freq = " << r->freq << endl;
                r = r->next;
            }
        }
    }
    void delete_frm_freq (int key) {
        //auto p = freq_list[hash[key]->freq];
        //delete_cur(p.first, p.second, hash[key]);//<<<Will this work? No, because it will update the local head/tail, not the actual head tail.
        delete_cur(freq_list[hash[key]->freq].first, freq_list[hash[key]->freq].second, hash[key]);//<<<<<You need to implement as this
        if (freq_list[hash[key]->freq].first == NULL) {
            freq_list.erase(hash[key]->freq);         
        }
        hash.erase(key);
    }
    
    void move_upper (int key) {///<<<If you see that you need to use same logic again and again, don't be lazy. Create a separate func. It will make it much easier going forward
        delete_cur(freq_list[hash[key]->freq].first, freq_list[hash[key]->freq].second, hash[key]);
        if (freq_list[hash[key]->freq].first == NULL) {
            freq_list.erase(hash[key]->freq);   
        }
        hash[key]->freq++;
        insert_last(freq_list[hash[key]->freq].first, freq_list[hash[key]->freq].second, hash[key]);        
    }
public:
    LFUCache(int capacity) {
        size = capacity;
    }
    
    int get(int key) {
        if (size == 0)
            return -1;
        auto it = hash.find(key);
        if (it == hash.end())
            return -1;
        move_upper(key);
        return hash[key]->val;
    }
    
    void put(int key, int value) {
        if (size == 0)
            return;
        auto it = hash.find(key);
        if (it != hash.end()) {
            move_upper(key);
            hash[key]->val = value;
        } else {
            if (hash.size() == size) {
                int key_to_del = freq_list.begin()->second.first->key;
                delete_frm_freq(key_to_del);
            }
            Node *n = new Node(key, value, 1);
            insert_last(freq_list[1].first, freq_list[1].second, n);
            hash[key] = n;
        }
    }
};


44. How would you implement a unorded_map<pair<int, int>, bool>? Note that, this will not work because it does not know how to use pair<int, int> as key (it doesn't know how to hash it). So, you need to provide your own hash function.  Note that, in  43, we defined priority_queue with custom object. There we implemented () oprator in Cmp. There we passed two Elements of priority queue and we compared them. But, here, we just need to pass one element of the hash and calculate the hash as following.

struct HashFunc {//<<<This can be a struct and define it outside of the class
    int operator()(const pair<int, int> &p) const {//<<<<You only need to pass the key as reference. 
                                                   //<<<<The return value is int. parameter and function, both has to be cosnt. Otherwise, you will get compilatio  error.
        return  p.first * p.second % 100;//<<<Define a hash function any way you like 
    }    
};

class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        string res;
        unordered_map<pair<int, int>, string, HashFunc> hash;//<<<Here you need to pass the hashfunc as third argument
}        
        
Howwould you use hashset instead? I often forget this.

It would be like:

unordered_set<int> hs;//<<<Not "hash_set" or "hashset"
hs.insert(5);//<<<<<<Not hs.push_back(5);

if (hs.count(5))//<<< this  is how we lookup.

We can also use find() in the same way as hash.
              
45. From Dr. Nesterenko's slide, you can append strings in two ways:

string s = "Hello";

s = s + " world";
s.append(" world");

Both are fine. Don't worry about creating stringbuffer.

Also, note that std::string doesn't have strcpy(). For instance, this will not compile:

tmp.strcpy(s, i, s_idx);

So, if you need to copy part of the string to another string, use "+".

Also note that, Following is not allowed!!!! (I often try this). Dr. Nesterenko's slide mentioned this
s = "Hello" + " world";//<<< You cannot apply "+" operartor on "Hello"


Also, how would you create a string of size 9?

string s(9)//<<<<Not right. This will work for vector, not for string.

Do this:

string s;
s.resize(9);

In most of time, create an empty string with "string s;". And then append to it.

How to earse part of the string?

tmp.erase(tmp_idx);//<<< Erase everything from tmp_idx to the end.
s.erase(0, num_spaces);//<<<It will erase num_spaces spaces from index 0


How to create substring? This is often used;

string sub = s.substr(offset, len);
string sub = s.substr(offset);//<<<In this case, it will return everything from the offset


How to convert string to number?

int a = atoi(s.c_str());


How would you search a char or string within a string? From Dr. Nesterenko's slide, you can do:

pos = s.find('.');//<<<This will find from the beginning
pos = s.find('.', start);//<<<This will start from index 'start'

if (pos == string::npos)//<<<not that, this is string::npos, not s::npos. What is string::npos. This is actaully a static const int whose value is -1.
  cout << "The string was not found";
  
If you want to search multuple times in a string for example in https://leetcode.com/problems/compare-version-numbers/.

You can always start from "pos + 1". But, when you reach string::npos, adding 1 will make it start searching from the beginning. So, idea is if you reach the end, you should start looking from index = length_of_the_string. For instance, this is the solution of the above problem:

    int compareVersion(string version1, string version2) {
        int pos1 = 0, pos2 = 0, start1 = 0, start2 = 0;
        int rev1, rev2;
        
        do {
            pos1 = version1.find('.', start1);
            pos2 = version2.find('.', start2);
            
            if (pos1 == string::npos) {
                rev1 = atoi(version1.substr(start1).c_str());
            } else {
                rev1 = atoi(version1.substr(start1, pos1 - start1 + 1).c_str());
            }
            
            if (pos2 == string::npos) {
                rev2 = atoi(version2.substr(start2).c_str());
            } else {
                rev2 = atoi(version2.substr(start2, pos2 - start2 + 1).c_str());
            }
            
            if (rev1 < rev2)
                return  -1;
            else if (rev1 > rev2)
                return 1;
            if (pos1 != string::npos)
                start1 = pos1 + 1;
            else
                start1 = version1.length();//<<<<If you reach end, start past the last character. Even starting from the last character will have wrong result
            if (pos2 != string::npos)
                start2 = pos2 + 1;
            else
                start2 = version2.length();
        } while (pos1 != string::npos || pos2 != string::npos);
        
        return 0;
    }
};  

46. How to initalize a vector? Can you initialize a vector of vector? Can you initialize in class declaration or you need to do it inside function? 

You can all of these. You can do it as:

class Solution {
        vector<vector<char>> map = {
            {' '},
            {},
            {'a', 'b', 'c'},
            {'d', 'e', 'f'},
            {'g', 'h', 'i'},
            {'j', 'k', 'l'},
            {'m', 'n', 'o'},
            {'p', 'q', 'r', 's'},
            {'t', 'u', 'v'},
            {'w', 'x', 'y', 'z'},
        };
    void letterCombinations_inner(string digits, int idx, 
                                  string &cur, vector<string> &res) {
    }
public:
    vector<string> letterCombinations(string digits) {

    }
};

47. How to check if number is a digit or alpha or alphanumeric? How to check if a character is upper or lower?

isahpha()
isdigit()
isalnum()//<<<This is not isalphanum().
islower()
isupper()
ispunct()
isspace()
tolower()
toupper()

How would you check if a string is a number? Note that there is no isnum(), or isnumber() or isnumeric() even though there is isalnum().

You can do this to check if a string is a number;

if (isdigit(s[0])) ///<<<< But this will not work for negative number.

So, right solution is do:

if (isdigit(s[s.length() - 1])) 

The functions are taken from Dr. Nesterenko's example.

48.     bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int n = matrix.size();//<<<Always do this, instead of using matrix.size() or arr.size() all the time
        
        
49. Sometimes, I debate weather to use DP or backtarcking? Note that thehy are very different problem. DP is optimization problem wheereas backtracking find all the combination.

50. https://leetcode.com/problems/search-a-2d-matrix-ii

How would you solve this?

I tend to use BFS. But, can you do better? Remember, if you need to do some sort of search, and the numbers are sorted, you can do better => Bibary search.

How would implement binary search here? This is not very clean. Pretty messy. Can you do better?

How about do DFS from top-right or bottom left? What is the benefit? Search space is shrinked. If we start from top-left and bottom-right, search space is huge, because both in creasing or descreasing. If you start from top-right, you only need to visit either left or down. Note that, you don't really need DFS here.

class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int m = matrix.size(), n = matrix[0].size();//<<<<<<<ALWAYS DO THIS. Makes code much cleaner and easier
        int row = 0, col = n -1;
        while (row >= 0 && col >= 0 && row < m && col < n) {
            if (matrix[row][col] == target)
                return true;
            else if (target > matrix[row][col])
                row++;
            else
                col--;
        }
        return false;
    }
};

51. How would you define 2D array?

int arr[4][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};//<<<<<<


Not:

int arr[][] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
int arr[4][] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};
int arr[][2] = {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};

52. https://leetcode.com/problems/evaluate-reverse-polish-notation/ 

Here, you need to implement something like:

    int eval (char ch, int a, int b) {
        switch(ch) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b;
        }
        return 0;
    }

What's wrong with this? Even though the final result of the problem is an integer, there is no guarntee that intermediate nuumbers are. So, it can overflow. Anytime you do "+" or "*", think if you need to store in a long instead of int as:

    long eval (char ch, long a, long b) {
        switch(ch) {
            case '+': return a + b;
            case '-': return a - b;
            case '*': return a * b;
            case '/': return a / b;
        }
        return 0;
    }

52. https://leetcode.com/problems/minesweeper/

I had hard time understanding the requirement. Most important part is:

If a cell is unrevealed, and at least one of it's neighbor is revealed, just count how many mines are there around the cell (revealed or unreaveal mines). Then replace the cell with that number.

If a cell is unrevealed and all it's neighbors are unrevealed, the recursively unreveal the neighbors.


53. How would define a Trie node?

struct Node {
//  char ch;//<<<<Note that, in trie, edge represents the value. So, you don't really need this. I often mistakenly add this. Don't do it
  unordered_map<char, Node *> child;//<<< You can have a hash instead of array 
  bool isLeaf;
  Node(char c) {
//      ch = c;
      isLeaf = false;
  }  
};

54. https://leetcode.com/problems/top-k-frequent-elements/ 

How would you implement this?

Note that, heap is a magical data structure. You can throw number number to it and then extract numbers in greater/smaller order without sorting.

Now, remember https://leetcode.com/problems/lfu-cache/

Can you use heap there as well?

No, there we needed to modify the count on the fly. Heap is not good for that (unless you create your own heap). In order to use heap, we have to have frequency of the element readily avaialable like https://leetcode.com/problems/top-k-frequent-elements/

Now, look at the following implementation. What's wrong with this? What is the runtime of the program?

struct Cmp {
    bool operator()(pair<int, int> &p1, pair<int, int> &p2) {
        return p1.second < p2.second;
    }    
};

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> hash;
        priority_queue<pair<int, int>, vector<pair<int, int>>, Cmp> pq;
        vector<int> res(k);
        
        for (auto e : nums)
            hash[e]++;
        
        for (auto &e : hash) {
            pq.push(e);
        }
        
        for (int i = 0; i < k; i++) {
            res[i] = pq.top().first;
            pq.pop();
        }
        
        return res;
    }
};

Note that, we are creating a heap of size n. If we do that, cost of constructing the heap would be nlogn. So, no benefit. In order for the heap to be effective, the heap size should be k. Look at the code:

struct Cmp {
    bool operator()(pair<int, int> &p1, pair<int, int> &p2) {
        return p1.second > p2.second;
    }    
};

class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> hash;
        priority_queue<pair<int, int>, vector<pair<int, int>>, Cmp> pq;
        vector<int> res(k);
        
        for (auto e : nums)
            hash[e]++;
        
        for (auto &e : hash) {
            pq.push(e);
            if (pq.size() > k)//<<<<We don't really need the heap larger than k. So, when it reaches the limit, keep dropping from it. Also not that, in this case, we need min heap, not max heap!!!
                pq.pop();
        }
        
        for (int i = 0; i < k; i++) {
            res[i] = pq.top().first;
            pq.pop();
        }
        
        return res;
    }
};

What's the time complexity? O (nlogk)

55. https://leetcode.com/problems/find-median-from-data-stream/

Here, you will need a min and max heap? What will be the condition of Cmp for min and max?

It would be:

struct CmpMin {
    bool operator()(int a, int b) {
        return a > b;
    }    
};

struct CmpMax {
    bool operator()(int a, int b) {
        return a < b;
    }    
};

class MedianFinder {
    priority_queue<int, vector<int>, CmpMin> pqmin;//<<<Note for min, we need to cheak greater (the opposite)
    priority_queue<int, vector<int>, CmpMax> pqmax;//<<<For max, we need to check smaller (the opposite)

56. https://leetcode.com/problems/design-twitter/

Here, it can be tempting to implememt tweets as:

unordered_map<int, list<pair<int, int>>> tweets;

This is because to find most recent 10 tweets, we need to access tweets like a linked list (get next node from current node). How would you implement the priority_queue then? 

I think that I would implement it as:

        priority_queue<pair<int, int>::iterator, vector<pair<int, int>::iterator>, Cmp> pq;
        
Problem with this approach is how would you if the iterator has reach the end?

You also need to store the person's id in the node so that you can get the list. Another approach would be not to use list. Implement your own Linkedlist. This is actaully better.

57. https://leetcode.com/problems/subsets/

How would you implemement this? 

Note that, if you keep another vector to keep track, that's not right (will get TLE); why? In backtarcaking, if you have a same node again, you should use memorization. For this, you should use each state a vector. This is how we can implement it.

struct HashFunc {
    int operator()(const vector<int> &v) const {//<<<See we can use vector as a key. Don't forget the const, otherwise it will not work. Also don't forget the reference. Otherwise it will not work. I often forget those
        long long sum = 0;
        
        for (auto e : v)
            sum += e;
        return sum;
    }    
};

class Solution {
    void subsets_inner(vector<int>& nums, 
                       unordered_set<vector<int>, HashFunc> &us, vector<vector<int>> &res) {
        int n = nums.size();
        
        if (us.count(nums))
            return;
        
        res.push_back(nums);
        us.insert(nums);
        
        if (n == 1)
            return;
        
        for (int i = 0; i < n; i++) {
            int tmp = nums[i];
            nums.erase(nums.begin() + i);
            subsets_inner(nums, us, res);
            nums.insert(nums.begin() + i, tmp);//<<<This is how you can insert inside a vector
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        int n = nums.size();
        vector<vector<int>> res;
        vector<int> valid(n);
        unordered_set<vector<int>, HashFunc> us;//<<<This is how you create a hash with custom function. YOu need 2 arguments, not 3
        
        res.push_back(vector<int>());//<<<This is how you can add an empty vector
        subsets_inner(nums, us, res);
        return res;
    }
};

58. What is the difference between queue and dequeue?

In deque, you add/delete from both front and back. In queue, you cannot delete from back. Note that, in queue, you have back() to access the back. But, you cannot delete it.

59. How to initilize an array?

class MyHashSet {
    const static int size = 100;//<<It has to be cosnt static. Only const will not work. Also define it inside the class
    Node *arr[size] = {NULL};//<<<You must initialize it. Ottherwise, it will have garbage value
public:
    MyHashSet() {
    }
    
60. What's wrong with the code?

struct HashFunc {
    int operator()(const pair<int, int> &p) const {
        return abs((p.first + p.second)) % 1000; //<<This will cause too many collision
    }  
};
unordered_set<pair<int, int>, HashFunc> visit;        

Better approach would be:


struct HashFunc {
    int operator()(const pair<int, int> &p) const {
        return abs((p.first * p.second)) % 10000000;//<<< The keys are more spreadout
    }  
};
unordered_set<pair<int, int>, HashFunc> visit;
        
61. https://leetcode.com/problems/minimum-knight-moves/

How would you implement this? 

Note that, there is a contstraint. How would you use that?

I tend to use BFS. If the any nodes we visit exceeds the constrants, I prune those nodes. But, it's not right. Search can go outside of the constrained space, but come back to map properly.

Will BFS scale? 

No.. I then also tend to consider A* search given my previous experience. But, can you do better? Bi-directional search!!!! Use bideirectional search instead of A* all the time!!! More intuitive.

I then implemented bi-direcrectional search. But, I was getting TLE. Then I realized that I was doing BFS less efficieently. In BFS, I add a node. Then in queue, I extract a node from the queue. I check if it's visited. If it's already visited, then continue. Otherwise, mark it visited. And then expand all the edges of the node by adding them to the queue. We can make it little more efficienet by checking if the new adjacent node is already visited. If it's not aready visited, then add it to the queue.

But, we can actually make BFS more efficient. When add the first node to the queue, also mark it visited before entering into the loop. In the loop, you simply extract the node, process it. Then add all the adjacent nodes to the queue if they are not already visited. Note that, when we are adding a node to the queue, we immemdiately mark it visited. So, we don't need to check if it's visited inside the top of the loop. The bidirectional search code is as follows:

struct Node {
    int x;
    int y;
    int level;
    Node (int x_, int y_, int level_) {
        x = x_;
        y = y_;
        level = level_;
    }
};

struct HashFunc {
    int operator()(const pair<int, int> &p) const {
        return abs((p.first * p.second)) % 10000;
    }  
};
class Solution {
    int arr[8][2] = {{-1, 2}, {-2, 1}, {-2, -1}, {-1, -2}, 
                  {1, -2}, {2, -1}, {2, 1}, {1, 2}};
public:
    int minKnightMoves(int x, int y) {
        queue<Node> q1, q2;
        unordered_map<pair<int, int>, int, HashFunc> visit1, visit2;
        
        q1.push(Node(0, 0, 0));
        visit1[make_pair(0, 0)] = 0;//<<<mark it when adding to queue
        q2.push(Node(x, y, 0));
        visit2[make_pair(x, y)] = 0;//<<<mark it when adding to queue
        while (!q1.empty() && !q2.empty()) {
            Node n1 = q1.front();
            q1.pop();
            
            Node n2 = q2.front();
            q2.pop();
                                    //<<<Note that, here we don't need to check if the node it visited or not. We know that it's already visited bc when we add it, we immediately mark it visited.   
            auto it4 = visit2.find(make_pair(n1.x, n1.y));//<<<bi-directional search. Check if cur node is in other set
            if (it4 != visit2.end())
                return n1.level + it4->second;
            
            auto it5 = visit1.find(make_pair(n2.x, n2.y));//<<<bi-directional search. Check if cur node is in other set
            if (it5 != visit1.end())
                return n2.level + it5->second;
            
            for (int i = 0; i < 8; i++) {
                int to_add_x = n1.x + arr[i][0];
                int to_add_y = n1.y + arr[i][1];
                int to_add_level = n1.level + 1;
                auto itr = visit1.find(make_pair(to_add_x, to_add_y));
                if (itr == visit1.end()) {//<<<<When we add the children, we check if it's already visited, if not, we add to the queue and mark it visited immediately
                    q1.push(Node(to_add_x, to_add_y, to_add_level));
                    visit1[make_pair(to_add_x, to_add_y)] = to_add_level;//<<<<Marking it visited immediately
                }
            }            
            for (int i = 0; i < 8; i++) {
                int to_add_x = n2.x + arr[i][0];
                int to_add_y = n2.y + arr[i][1];
                int to_add_level = n2.level + 1;
                auto itr = visit2.find(make_pair(to_add_x, to_add_y));
                if (itr == visit2.end()) {//<<<<When we add the children, we check if it's already visited, if not, we add to the queue and mark it visited immediately
                    q2.push(Node(to_add_x, to_add_y, to_add_level));
                    visit2[make_pair(to_add_x, to_add_y)] = to_add_level;//<<<<Marking it visited immediately
                }
            }
        }
        return 0;
    }
}; 


Also, note how we implement bidirectional search. In every ieration, we need to check if the current node exists in other set. Sometimes, I mistakenly write a loop on all the nodes of a visit hash and check if any of the element exists in the other group. This is very unefficient and unnecessary.


Also note that, instead of using pair<int, int> as key, we can use string as a key (e.g. "0, 1"). That certainly makes code cleaner because you don't need to create custom hash. I thought I would get better performance with that. But, after trying, I didn't see performance improvement over pair<int, int>.

62. https://leetcode.com/problems/find-all-anagrams-in-a-string/

How would you implememt this?

In sliding window, I tend to think that, when we find a unmatch, we need to move start all the way to past end. But, that's not right. If we don't find a match, we should increase start one step only (if needed, look at my solution below). 

Also, when sliding window shoud stop? 

It should go until (end < size).

Here, in each iteration, check the end. If we find a match, then increase the end. Otherwise increase the start.

class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int m = s.length(), n = p.length(), start = 0, end = 0;
        int hash[26] = {0};
        vector<int> res;
        
        for (int i = 0; i < n; i++) {
            hash[p[i] - 'a']++;
        }
        
        while (end < m) {//<<<See when sliding window should stop
            if (hash[s[end] - 'a']) {//<<< If we find a match, end should be incremeneted
                hash[s[end] - 'a']--;
                if (end - start + 1 == n) {
                    res.push_back(start);
                    hash[s[start] - 'a']++;
                    start++;
                    end++;
                } else {
                    end++;    
                }
            } else {//<<< If we don't find a match, start should be incremented
                hash[s[start] - 'a']++;
                start++; 
            }
        }
        return res;
    }
};        
        
63. https://leetcode.com/problems/coin-change/

How would you solve this?

Note that, it's easy to confuse backtracking with DP. DP is also a combinatorial optimization prolem. The main difference between the two is backtracking is not an optimization pronlem whearas DP is. If a problem is a potential DP, try implementing in a bottom-up fashion. That leads to the solution usually.


DP can be only be applied if following two rules hold (typically you don't need to consider these while solving a problem): 

Overlapping subproblem
Principle of optimality - local oprtimal leads to gloabal optimal.

64. https://leetcode.com/problems/coin-change-ii/

How would you implement this?

Will backtacking work? Note that, in backtracking will produce same resulst multiple time. For intsance, if coins = {1, 2, 5} and amount = 6. In backtracking, it will produce
{1, 1, 1, 1, 2}, {1, 1, 1, 2, 1},... Problem is the are the same. So, backtracking doesn't work if multiple solution with different order actaully mean the same solution. One way to solve this is to store the result and check if a result is already added. However, this can be a very expensive solution because you need to sort the result before checking. Can you do better?

        
        
         
